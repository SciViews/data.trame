% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/subsetting.R
\name{subsetting}
\alias{subsetting}
\alias{[.data.trame}
\alias{$.data.trame}
\alias{set_}
\alias{let_}
\title{Subsetting data.trames}
\usage{
\method{[}{data.trame}(x, i, j, by, keyby, with = TRUE, drop = FALSE, ...)

\method{$}{data.trame}(x, name)

set_(x, i, j, value, byref = FALSE)

let_(x, i = NULL, j = seq_along(x), value)
}
\arguments{
\item{x}{A data.trame object.}

\item{i}{Selection of rows by indices, negative indices, logical or a formula}

\item{j}{Selection of columns by indices, negative indices, logical, names or
a formula (both i and j must be formulas simultaneously). If \verb{:=} is used
in the formula to create one or more new variables by reference, the
expression must be placed between \code{{}} to avoid operators precedence
issues, or better: \verb{:=} could be just replaced by \code{~}.}

\item{by}{Grouping columns (must be a formula and \code{j} must be also provided as
a formula)}

\item{keyby}{Either \code{TRUE}/\code{FALSE} if \code{by} is provided, or a formula (and \code{j}
must also be provided as a formula)}

\item{with}{Logical, whether to evaluate \code{j} in the data.trame if \code{TRUE} or
in the calling environment if \code{FALSE} (default is \code{TRUE}).  \code{with = FALSE}
is similar to tibble subsetting and it is forced when \code{i} or \code{j} are not
formulas.}

\item{drop}{Coerce to a vector if the returned data.trame only has one column}

\item{...}{Further arguments passed to the underlying \code{data.table} subsetting}

\item{name}{The name of the column to extract.}

\item{value}{The value to insert as subassignment in a data.trame object.}

\item{byref}{Logical, whether to use by reference or not (\code{FALSE} by default).}
}
\value{
A data.trame object, or a vector if \code{drop = TRUE} and the result has
only one column.
}
\description{
Subsetting data.trames uses a syntax similar to tibble, or formulas for \code{i},
\code{j}, and possibly \code{by} or \code{keyby} to use the data.table syntax instead.
}
\examples{
dtrm <- data.trame(
  a = 1:3,
  b = letters[1:3],
  c = factor(LETTERS[1:3])
)
# Subsetting rows, the tibble-way
dtrm[1:2, ]
dtrm[-1, ]
dtrm[c(TRUE, FALSE, TRUE), ]
# On the contrary to data.table, providing only one arg, means subsetting
# columns (like for data.frame or tibble)
dtrm[c(TRUE, FALSE, TRUE)]
dtrm[dtrm$a > 1, ] # Must fully qualify the column name
# Subsetting the data.table way, with formulas: no fully qualification needed
dtrm[~a > 1, ]

# Subsetting the columns, the tibble way
dtrm[, 1:2]
dtrm[, -1]
dtrm[, c(TRUE, FALSE, TRUE)]
dtrm[, c("a", "b")]
# You must set drop = TRUE explicitly to return a vector
dtrm[, 2] # Still a data.trame, like tibble, but unlike the data.frame method
dtrm[, 2, drop = TRUE] # Now a vector
# The selection is referentially transparent, i.e., you can do:
sel <- c("c", "b")
dtrm[, sel]
# Subsetting the columns, the data.table way, with formulas
dtrm[~1:2, ~.(b)]
dtrm[~1:2, ~b] # If not enclosed in .(), returns a vector instead
# Precautions are needed here because it is NOT referentially transparent:
dtrm[, ~..sel] # In data.table language, this is how you access `sel`

# Extended data.table syntax using i, j, by, or keyby with formulas
# Warning: due to precedence of operators, you must use braces here!
dtrm[, ~{d := paste0(b, c)}] # Changed in place (by reference!)
# Another form that does not need braces, but is less readable:
dtrm[, ~`:=`(e, paste0(b, a))]
# or equivalently:
dtrm[, ~let(e = paste0(b, a))]
# In this case, it is much better to just replace `:=` by `~`, but internally
# it uses set(). It is faster, but much more limited and cannot use by or
# or keyby:
dtrm[, f ~ paste0(c, a)]
# One can also use standard evaluation in that case using with = FALSE
dtrm[, f ~ paste0(dtrm$c, dtrm$a), with = FALSE]
#
# Take care when you provide only one argument:
# If it is a formula, the data.table syntax is used (select rows)
# otherwise, the data.frame syntax applies, and columns are selected!
dtrm[1:2] # All rows and 2 first columns
dtrm[~1:2] # All columns and 2 first rows!

# For $, on the contrary to data.frame/data.table, but like tibble,
# no partial match is allowed (returns NULL with a warning)
dtrm$count <- dtrm$c
names(dtrm)
dtrm$count #OK
#dtrm$co # Not OK, no partial match allowed
}
